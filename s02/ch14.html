<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript 복습 - 심화</title>

    <link
      id="prism-theme"
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.css"
    />
    <link rel="stylesheet" href="../css/style.css" />

    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-javascript.min.js"></script>
  </head>
  <body>
    <h1>2-13. 비동기 작업 처리하기 3 - Async/Await</h1>
    <button id="theme-toggle">🌙 다크 모드</button>

    <pre
      id="editor"
      class="language-javascript"
      contenteditable="true"
      spellcheck="false"
    >
// async
// 어떤 함수를 비동기 함수로 만들어주는 키워드
// 함수가 프로미스를 반환하도록 변환해주는 그런 키워드

async function getData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({
        name: "이정환",
        id: "winterlood",
      });
    }, 1500);
  });
}

// await
// async 함수 내부에서만 사용이 가능 한 키워드
// 비동기 함수가 다 처리되기를 기다리는 역할

// then과 비슷한 역할을 하지만
// 코드가 더 간결해지고 가독성이 좋아짐
async function printData() {
  const data = await getData();
  console.log(data);
}

printData();

// catch와 finally는 try와 조합하여 사용
async function getDataWithError() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject("데이터를 가져오는 데 실패했습니다");
    }, 2000);
  });
}

async function printDataWithError() {
  try {
    const data = await getDataWithError();
    console.log(data); // 이 줄은 실행되지 않음
  } catch (error) {
    console.error(error); // 데이터 가져오기 실패
  } finally {
    console.log("데이터 정리 작업 완료");
  }
}

printDataWithError();

</pre
    >

    <button id="run-btn">▶️ Run</button>
    <div id="output" class="console-output"></div>
    <!-- 기능 스크립트 -->
    <script src="../js/theme-toggle.js"></script>
    <script src="../js/editor.js"></script>
  </body>
</html>
